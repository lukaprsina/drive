{"version":3,"sources":["buildRoad.js","Artboard.js","App.js","index.js"],"names":["pointsToString","pointsArray","length","pathD","order","letter","coords","x","y","Artboard","props","artboardRef","useRef","useState","coordInfo","setCoordInfo","numberOfBackward","numberOfForward","angle","roadInfo","setRoadInfo","rotate","useDrag","event","args","newPoint","sumVector","a","k","multVector","deg","Math","atan2","PI","newRoadInfo","map","sort","b","i","useEffect","changeCoordInfo","newCoord","element","current","clientRect","getBoundingClientRect","right","left","bottom","top","maxRoadWidth","max","apply","road","windowBox","min","roadLength","roadWidth","getCoordinateInfo","window","addEventListener","removeEventListener","temp","points","addLanes","roads","debug","elements","forward","backward","strings","asphalt","line","striped","continous","center","curb","controls","lanes","add","remove","vectors","offsetBottom","lane","first","offsetTop","last","halfRoadLeft","lenDeg","halfRoadRight","laneBottomLeft","laneTopLeft","laneBottomRight","laneTopRight","roadBottomLeft","roadBottomRight","roadTopLeft","roadTopRight","roadTopMiddle","side","entries","indexRoad","indexLane","push","string","cx","cy","r","index","d","className","x1","y1","x2","y2","strokeDasharray","onClick","buildRoad","maxDistance","allLanes","j","firstPoint","lastPoint","calculatePoints","style","touchAction","ref","cos","sin","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7d2c31a3.chunk.js","sourcesContent":["import React from \"react\";\nimport { sumVector, lenDeg, multVector } from \"./Artboard\";\n\nfunction pointsToString(pointsArray) {\n  if (!(pointsArray && pointsArray.length)) {\n    return null;\n  }\n\n  let pathD = \"\";\n\n  for (const order of pointsArray) {\n    pathD += order.letter + \" \";\n\n    if (order.coords) {\n      for (const coords of order.coords) {\n        pathD += coords.x + \" \" + coords.y + \" \";\n      }\n    }\n  }\n  return pathD;\n}\n\nexport function buildRoad(points, coordInfo, rotate, addLanes) {\n  if (!(points && coordInfo)) {\n    return null;\n  }\n\n  const roads = {\n    debug: {\n      elements: { forward: [], backward: [] },\n      strings: { forward: [], backward: [] },\n    },\n    asphalt: {\n      elements: { forward: [], backward: [] },\n      strings: { forward: [], backward: [] },\n    },\n    line: {\n      elements: { striped: [], continous: [] },\n      strings: { striped: [], continous: [] },\n    },\n    center: {},\n    curb: {},\n  };\n\n  const controls = {\n    rotate: { strings: [] },\n    lanes: {\n      strings: {\n        forward: { add: [], remove: [] },\n        backward: { add: [], remove: [] },\n      },\n      elements: {\n        forward: {},\n        backward: {},\n      },\n    },\n  };\n\n  const vectors = {\n    offsetBottom: (lane) => sumVector(coordInfo, lane.first),\n\n    offsetTop: (lane) => sumVector(coordInfo, lane.last),\n\n    halfRoadLeft: (road) => lenDeg(coordInfo.roadWidth / 2, road.angle - 90),\n\n    halfRoadRight: (road) => lenDeg(coordInfo.roadWidth / 2, road.angle + 90),\n\n    laneBottomLeft: (lane, road) =>\n      sumVector(vectors.halfRoadLeft(road), vectors.offsetBottom(lane)),\n\n    laneTopLeft: (lane, road) =>\n      sumVector(vectors.halfRoadLeft(road), vectors.offsetTop(lane)),\n\n    laneBottomRight: (lane, road) =>\n      sumVector(vectors.halfRoadRight(road), vectors.offsetBottom(lane)),\n\n    laneTopRight: (lane, road) =>\n      sumVector(vectors.halfRoadRight(road), vectors.offsetTop(lane)),\n\n    roadBottomLeft: (road) =>\n      sumVector(\n        sumVector(road.backward[0].first, coordInfo),\n        vectors.halfRoadLeft(road)\n      ),\n\n    roadBottomRight: (road) =>\n      sumVector(\n        sumVector(road.forward[road.forward.length - 1].first, coordInfo),\n        vectors.halfRoadRight(road)\n      ),\n    roadTopLeft: (road) =>\n      sumVector(\n        sumVector(road.backward[0].last, coordInfo),\n        vectors.halfRoadLeft(road)\n      ),\n\n    roadTopRight: (road) =>\n      sumVector(\n        sumVector(road.forward[road.forward.length - 1].last, coordInfo),\n        vectors.halfRoadRight(road)\n      ),\n\n    roadTopMiddle: (road) =>\n      sumVector(\n        lenDeg(coordInfo.roadLength, road.angle),\n        sumVector(\n          lenDeg(\n            ((road.numberOfForward + road.numberOfBackward) *\n              coordInfo.roadWidth) /\n              2,\n            road.angle + 90\n          ),\n          vectors.roadBottomLeft(road)\n        )\n      ),\n  };\n  for (const side of [\"forward\", \"backward\"]) {\n    // fill both sides of the object\n    for (const [indexRoad, road] of points.entries()) {\n      // for every road\n\n      for (const [indexLane, lane] of road[side].entries()) {\n        // for every lane\n\n        //----ASPHALT---- strings//\n        roads.asphalt.strings[side].push(\n          pointsToString([\n            { letter: \"M\", coords: [vectors.offsetBottom(lane)] },\n            {\n              letter: \"L\",\n              coords: [\n                vectors.laneBottomLeft(lane, road),\n                vectors.laneTopLeft(lane, road),\n                vectors.laneTopRight(lane, road),\n                vectors.laneBottomRight(lane, road),\n              ],\n            },\n            { letter: \"Z\" },\n          ])\n        );\n\n        //-----DEBUG----- strings//\n        roads.debug.strings[side].push([\n          vectors.offsetBottom(lane),\n          vectors.offsetTop(lane),\n        ]);\n\n        //-----LINE------ strings//\n        if (indexLane !== road[side].length - 1 || side === \"backward\") {\n          if (indexLane === road[side].length - 1 && side === \"backward\") {\n            roads.line.strings.continous.push([\n              vectors.laneBottomRight(lane, road),\n              vectors.laneTopRight(lane, road),\n            ]);\n          } else {\n            roads.line.strings.striped.push([\n              vectors.laneBottomRight(lane, road),\n              vectors.laneTopRight(lane, road),\n            ]);\n          }\n        }\n      }\n\n      //-----ROTATE---- strings//\n      if (side === \"backward\") {\n        controls.rotate.strings.push({\n          vectors: vectors.roadTopMiddle(road),\n          order: road.order,\n        });\n      }\n\n      //-----CENTER---- strings//\n      if (indexRoad === 0) {\n        roads.center.string = pointsToString([\n          {\n            letter: \"M\",\n            coords: [vectors.roadBottomLeft(road)],\n          },\n        ]);\n      }\n      roads.center.string += pointsToString([\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomLeft(road), vectors.roadBottomRight(road)],\n        },\n      ]);\n\n      roads.coordInfo = <circle cx={coordInfo.x} cy={coordInfo.y} r=\"5\" />;\n\n      //-----CURB----- strings//\n      if (indexRoad === 0) {\n        roads.curb.string = pointsToString([\n          {\n            letter: \"M\",\n            coords: [vectors.roadBottomLeft(road)],\n          },\n        ]);\n      }\n      roads.curb.string += pointsToString([\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomLeft(road), vectors.roadTopLeft(road)],\n        },\n        {\n          letter: \"M\",\n          coords: [vectors.roadTopRight(road)],\n        },\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomRight(road)],\n        },\n      ]);\n      if (indexRoad === points.length - 1) {\n        roads.curb.string += pointsToString([\n          {\n            letter: \"L\",\n            coords: [vectors.roadBottomLeft(points[0])],\n          },\n        ]);\n      }\n\n      //----ASPHALT---- elements//\n      roads.asphalt.elements[side] = roads.asphalt.strings[\n        side\n      ].map((lane, index) => (\n        <path d={lane} key={index} className={side + \"-asphalt\"} />\n      ));\n\n      //-----DEBUG----- elements//\n      roads.debug.elements[side] = roads.debug.strings[\n        side\n      ].map((coords, index) => (\n        <line\n          x1={coords[0].x}\n          y1={coords[0].y}\n          x2={coords[1].x}\n          y2={coords[1].y}\n          key={index}\n          className={side + \"-debug\"}\n        />\n      ));\n\n      //-----LINE------ elements//\n      roads.line.elements.striped = roads.line.strings.striped.map(\n        (coords, index) => (\n          <line\n            x1={coords[0].x}\n            y1={coords[0].y}\n            x2={coords[1].x}\n            y2={coords[1].y}\n            key={index}\n            className={side + \"-line\"}\n            strokeDasharray=\"30, 60\"\n          />\n        )\n      );\n      roads.line.elements.continous = roads.line.strings.continous.map(\n        (coords, index) => (\n          <line\n            x1={coords[0].x}\n            y1={coords[0].y}\n            x2={coords[1].x}\n            y2={coords[1].y}\n            key={index}\n            className={side + \"-line\"}\n          />\n        )\n      );\n\n      if (side === \"backward\") {\n        //-LANE CONTROL- strings//\n        controls.lanes.strings.forward.remove.push(\n          sumVector(\n            vectors.roadBottomLeft(road),\n            lenDeg(coordInfo.roadLength / 3, road.angle)\n          )\n        );\n\n        controls.lanes.strings.forward.add.push(\n          sumVector(\n            vectors.roadBottomLeft(road),\n            lenDeg((coordInfo.roadLength * 2) / 3, road.angle)\n          )\n        );\n\n        controls.lanes.strings.backward.remove.push(\n          sumVector(\n            vectors.roadBottomRight(road),\n            lenDeg(coordInfo.roadLength / 3, road.angle)\n          )\n        );\n\n        controls.lanes.strings.backward.add.push(\n          sumVector(\n            vectors.roadBottomRight(road),\n            lenDeg((coordInfo.roadLength * 2) / 3, road.angle)\n          )\n        );\n\n        //-LANE CONTROL- elements//\n        controls.lanes.elements.forward.remove = controls.lanes.strings.forward.remove.map(\n          (coords, index) => (\n            <circle\n              cx={coords.x}\n              cy={coords.y}\n              r=\"10\"\n              className=\"add-lane\"\n              key={index}\n              onClick={() => addLanes(index, \"Forward\", -1)}\n            />\n          )\n        );\n\n        controls.lanes.elements.forward.add = controls.lanes.strings.forward.add.map(\n          (coords, index) => (\n            <circle\n              cx={coords.x}\n              cy={coords.y}\n              r=\"10\"\n              className=\"add-lane\"\n              key={index}\n              onClick={() => addLanes(index, \"Forward\", 1)}\n            />\n          )\n        );\n\n        controls.lanes.elements.backward.remove = controls.lanes.strings.backward.remove.map(\n          (coords, index) => (\n            <circle\n              cx={coords.x}\n              cy={coords.y}\n              r=\"10\"\n              className=\"add-lane\"\n              key={index}\n              onClick={() => addLanes(index, \"Backward\", -1)}\n            />\n          )\n        );\n\n        controls.lanes.elements.backward.add = controls.lanes.strings.backward.add.map(\n          (coords, index) => (\n            <circle\n              cx={coords.x}\n              cy={coords.y}\n              r=\"10\"\n              className=\"add-lane\"\n              key={index}\n              onClick={() => addLanes(index, \"Backward\", 1)}\n            />\n          )\n        );\n      }\n    }\n  }\n\n  //-----CENTER---- elements//\n  roads.center.element = <path d={roads.center.string} className=\"center\" />;\n\n  //-----CURB----- elements//\n  roads.curb.element = <path d={roads.curb.string} className=\"curb\" />;\n\n  //----ROTATE---- elements//\n  controls.rotate.elements = controls.rotate.strings.map((coords, index) => (\n    <circle\n      cx={coords.vectors.x}\n      cy={coords.vectors.y}\n      r=\"10\"\n      className=\"rotate\"\n      key={index}\n      {...rotate(coords.order)}\n    />\n  ));\n\n  return [roads, controls];\n}\n\n//problemi z keyi\n","import React, { useState, useEffect, useRef } from \"react\";\nimport { useDrag } from \"react-use-gesture\";\nimport { buildRoad } from \"./buildRoad\";\n\nexport default function Artboard(props) {\n  /* svg ref */\n  const artboardRef = useRef();\n\n  const [coordInfo, setCoordInfo] = useState({});\n\n  const [roadInfo, setRoadInfo] = useState([\n    {\n      numberOfBackward: 1,\n      numberOfForward: 2,\n      angle: 0,\n      order: 0,\n    },\n    {\n      numberOfBackward: 1,\n      numberOfForward: 1,\n      angle: 110,\n      order: 1,\n    },\n    {\n      numberOfBackward: 2,\n      numberOfForward: 3,\n      angle: 170,\n      order: 2,\n    },\n    {\n      numberOfBackward: 1,\n      numberOfForward: 1,\n      angle: 300,\n      order: 3,\n    },\n  ]);\n\n  const rotate = useDrag(({ event, args: [order] }) => {\n    if (event.x && event.y) {\n      const newPoint = sumVector(event, multVector(coordInfo, -1));\n      const newAngle = Math.atan2(newPoint.y, newPoint.x);\n\n      let deg = newAngle * (180 / Math.PI);\n      deg %= 360;\n      if (deg < 0) {\n        deg += 360;\n      }\n\n      // shallow copy\n      const newRoadInfo = roadInfo.map((a) => ({ ...a }));\n      newRoadInfo.sort((a, b) => a.angle - b.angle);\n\n      for (let i = 0; i < newRoadInfo.length; i++) {\n        if (order === newRoadInfo[i].order) {\n          newRoadInfo[i].angle = deg;\n        }\n      }\n\n      setRoadInfo(newRoadInfo);\n    }\n  });\n\n  function addLanes(index, side, add) {\n    const newRoadInfo = roadInfo.map((a) => ({ ...a }));\n\n    const numberOfLanes = newRoadInfo[index][\"numberOf\" + side];\n\n    if (numberOfLanes > 1 || add > 0) {\n      newRoadInfo[index][\"numberOf\" + side] += add;\n    }\n\n    setRoadInfo(newRoadInfo);\n  }\n\n  useEffect(() => {\n    function changeCoordInfo() {\n      /* get coordinates of the svg element */\n      const newCoord = getCoordinateInfo(artboardRef, roadInfo);\n      /* sets state */\n      setCoordInfo(newCoord);\n    }\n\n    changeCoordInfo();\n    /* call getCoordinateInfo on every window change */\n    window.addEventListener(\"resize\", changeCoordInfo);\n\n    return () => {\n      window.removeEventListener(\"resize\", changeCoordInfo);\n    };\n  }, [artboardRef, roadInfo]);\n\n  /* get a list of all the road points */\n  const points = calculatePoints(roadInfo, coordInfo);\n\n  /* create elements based on road points */\n  const temp = buildRoad(points, coordInfo, rotate, addLanes);\n  const [roads, controls] = temp ? temp : [null, null];\n\n  return (\n    // touch-action ensures that chrome doesnt stop the drag after a few frames,\n    // but it doesn't work on svg elements\n    // https://stackoverflow.com/questions/45678190/dynamically-disabling-touch-action-overscroll-for-svg-elements\n    <div style={{ touchAction: \"none\" }}>\n      <svg className=\"artboard\" ref={artboardRef}>\n        {roads ? roads.asphalt.elements.forward : null}\n        {roads ? roads.asphalt.elements.backward : null}\n        {roads ? roads.center.element : null}\n        {roads ? roads.curb.element : null}\n        {roads ? roads.line.elements.continous : null}\n        {roads ? roads.line.elements.striped : null}\n        {/* {roads ? roads.coordInfo : null} */}\n\n        {controls ? controls.rotate.elements : null}\n        {controls ? controls.lanes.elements.forward.remove : null}\n        {controls ? controls.lanes.elements.forward.add : null}\n        {controls ? controls.lanes.elements.backward.remove : null}\n        {controls ? controls.lanes.elements.backward.add : null}\n\n        {!roads ? <text>Loading</text> : null}\n      </svg>\n    </div>\n  );\n}\n\nfunction calculatePoints(roadInfo, coordInfo) {\n  const points = [];\n\n  if (!(coordInfo && coordInfo.roadLength && coordInfo.roadWidth)) {\n    return null;\n  }\n\n  for (let i = 0; i < roadInfo.length; i++) {\n    const road = roadInfo[i];\n\n    /* maxDistance = pixels from the center to the edge */\n    const maxDistance =\n      ((road.numberOfForward + road.numberOfBackward - 1) *\n        coordInfo.roadWidth) /\n      2;\n    points[i] = {\n      forward: [],\n      backward: [],\n      maxDistance,\n      angle: road.angle,\n      order: road.order,\n      numberOfForward: road.numberOfForward,\n      numberOfBackward: road.numberOfBackward,\n    };\n\n    const allLanes = road.numberOfForward + road.numberOfBackward;\n\n    for (let j = 0; j < allLanes; j++) {\n      let firstPoint = sumVector(\n        /* sum vector pointing east to get left or right */\n        lenDeg(maxDistance - j * coordInfo.roadWidth, road.angle - 90),\n        /* and the vector, responsible for making the center area */\n        lenDeg(coordInfo.maxRoadWidth * coordInfo.roadWidth * 0.8, road.angle)\n      );\n\n      let lastPoint = sumVector(\n        firstPoint,\n        lenDeg(coordInfo.roadLength, road.angle)\n      );\n\n      if (j >= road.numberOfForward) {\n        points[i].forward.push({ first: firstPoint, last: lastPoint });\n      } else {\n        points[i].backward.push({ first: firstPoint, last: lastPoint });\n      }\n    }\n  }\n  return points;\n}\n\nexport function lenDeg(d, angle) {\n  const deg = (angle * Math.PI) / 180;\n  const x = d * Math.cos(deg);\n  const y = d * Math.sin(deg);\n  return { x, y };\n}\n\nexport function sumVector(a, b) {\n  const x = a.x + b.x;\n  const y = a.y + b.y;\n  return { x, y };\n}\n\nexport function multVector(a, k) {\n  const x = a.x * k;\n  const y = a.y * k;\n  return { x, y };\n}\n\nexport function getCoordinateInfo(element, roadInfo) {\n  if (!element.current) {\n    return null;\n  }\n\n  const clientRect = element.current.getBoundingClientRect();\n  const x = (clientRect.right - clientRect.left) / 2;\n  const y = (clientRect.bottom - clientRect.top) / 2;\n\n  const maxRoadWidth = Math.max.apply(\n    Math,\n    roadInfo.map((road) => {\n      return road.numberOfForward + road.numberOfBackward;\n    })\n  );\n  const windowBox = Math.min(x, y);\n  const roadLength = windowBox / 2;\n  const roadWidth = (windowBox / maxRoadWidth) * 0.6;\n\n  return { x, y, roadLength, roadWidth, maxRoadWidth };\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport Artboard from \"./Artboard.js\";\n\n/* import { Typography } from \"@material-ui/core\";\nimport { useSpring, config, animated } from \"react-spring\";\nimport { useGesture } from \"react-use-gesture\"; */\n\nexport default function App() {\n  return (\n    <>\n      {<Artboard />}\n      {/* <Solution />\n      <Inventory /> */}\n    </>\n  );\n}\n/* function Solution() {\n  return (\n    <Typography variant=\"body1\">\n      Solution\n      <br />\n    </Typography>\n  );\n}\n\nfunction Inventory() {\n  return (\n    <>\n      <Item />\n      <Item />\n    </>\n  );\n}\n\nfunction Item() {\n  const [{ x, y }, setSpring] = useSpring(() => ({\n    x: 0,\n    y: 0,\n    config: config.stiff,\n  }));\n\n  const [isClicking, setIsClicking] = useState(false);\n\n  const bind = useGesture({\n    onDrag: ({ down, movement: [mx, my] }) => {\n      setSpring({ x: down ? mx : 0, y: down ? my : 0 });\n      setIsClicking(!mx && !my);\n    },\n    onDragEnd: ({ event }) => {\n      if (isClicking) {\n        console.log(\"Click\");\n      } else {\n        console.log(\"Move\", event.x, event.y);\n      }\n    },\n  });\n\n  return <animated.div className=\"drag\" {...bind()} style={{ x, y }} />;\n}\n */","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}