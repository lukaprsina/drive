{"version":3,"sources":["buildRoad.js","Artboard.js","App.js","index.js"],"names":["pointsToString","pointsArray","length","pathD","order","letter","coords","x","y","lenDeg","d","angle","deg","Math","PI","cos","sin","sumVector","a","b","Artboard","props","artboardRef","useRef","roadInfo","useState","coordInfo","setCoordInfo","useEffect","changeCoordInfo","newCoord","element","current","clientRect","getBoundingClientRect","right","left","bottom","top","maxRoadWidth","max","apply","map","road","numberOfForward","numberOfBackward","windowBox","min","roadLength","roadWidth","getCoordinateInfo","window","addEventListener","removeEventListener","roads","points","debug","elements","forward","backward","strings","asphalt","line","center","curb","vectors","offsetBottom","lane","first","offsetTop","last","halfRoadLeft","halfRoadRight","laneBottomLeft","laneTopLeft","laneBottomRight","laneTopRight","roadBottomLeft","roadBottomRight","roadTopLeft","roadTopRight","side","entries","indexRoad","indexLane","push","string","index","className","x1","y1","x2","y2","stroke-dasharray","buildRoad","i","maxDistance","allLanes","j","firstPoint","lastPoint","calculatePoints","id","ref","Typography","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f951a9bd.chunk.js","sourcesContent":["import React from \"react\";\nimport { sumVector, lenDeg } from \"./Artboard\";\n\nfunction pointsToString(pointsArray) {\n  if (!(pointsArray && pointsArray.length)) {\n    return null;\n  }\n\n  let pathD = \"\";\n\n  for (const order of pointsArray) {\n    pathD += order.letter + \" \";\n\n    if (order.coords) {\n      for (const coords of order.coords) {\n        pathD += coords.x + \" \" + coords.y + \" \";\n      }\n    }\n  }\n  return pathD;\n}\n\nexport function buildRoad(points, coordInfo) {\n  if (!(points && coordInfo)) {\n    return null;\n  }\n\n  const roads = {\n    debug: {\n      elements: { forward: [], backward: [] },\n      strings: { forward: [], backward: [] },\n    },\n    asphalt: {\n      elements: { forward: [], backward: [] },\n      strings: { forward: [], backward: [] },\n    },\n    line: { strings: [] },\n    center: {},\n    curb: {},\n  };\n\n  const vectors = {\n    offsetBottom: (lane) => sumVector(coordInfo, lane.first),\n\n    offsetTop: (lane) => sumVector(coordInfo, lane.last),\n\n    halfRoadLeft: (road) => lenDeg(coordInfo.roadWidth / 2, road.angle - 90),\n\n    halfRoadRight: (road) => lenDeg(coordInfo.roadWidth / 2, road.angle + 90),\n\n    laneBottomLeft: (lane, road) =>\n      sumVector(vectors.halfRoadLeft(road), vectors.offsetBottom(lane)),\n\n    laneTopLeft: (lane, road) =>\n      sumVector(vectors.halfRoadLeft(road), vectors.offsetTop(lane)),\n\n    laneBottomRight: (lane, road) =>\n      sumVector(vectors.halfRoadRight(road), vectors.offsetBottom(lane)),\n\n    laneTopRight: (lane, road) =>\n      sumVector(vectors.halfRoadRight(road), vectors.offsetTop(lane)),\n\n    roadBottomLeft: (\n      road //poglej kuk se to izrazi z 0 in length - 1\n    ) =>\n      sumVector(\n        sumVector(road.backward[0].first, coordInfo),\n        vectors.halfRoadLeft(road)\n      ),\n\n    roadBottomRight: (road) =>\n      sumVector(\n        sumVector(road.forward[road.forward.length - 1].first, coordInfo),\n        vectors.halfRoadRight(road)\n      ),\n    roadTopLeft: (road) =>\n      sumVector(\n        sumVector(road.backward[0].last, coordInfo),\n        vectors.halfRoadLeft(road)\n      ),\n\n    roadTopRight: (road) =>\n      sumVector(\n        sumVector(road.forward[road.forward.length - 1].last, coordInfo),\n        vectors.halfRoadRight(road)\n      ),\n  };\n  for (const side of [\"forward\", \"backward\"]) {\n    // fill both sides of the object\n    for (const [indexRoad, road] of points.entries()) {\n      // for every road\n\n      for (const [indexLane, lane] of road[side].entries()) {\n        // for every lane\n\n        //----ASPHALT---- strings//\n        roads.asphalt.strings[side].push(\n          pointsToString([\n            { letter: \"M\", coords: [vectors.offsetBottom(lane)] },\n            {\n              letter: \"L\",\n              coords: [\n                vectors.laneBottomLeft(lane, road),\n                vectors.laneTopLeft(lane, road),\n                vectors.laneTopRight(lane, road),\n                vectors.laneBottomRight(lane, road),\n              ],\n            },\n            { letter: \"Z\" },\n          ])\n        );\n\n        //-----DEBUG----- strings//\n        roads.debug.strings[side].push([\n          vectors.offsetBottom(lane),\n          vectors.offsetTop(lane),\n        ]);\n\n        //-----LINE------ strings//\n        if (indexLane !== road[side].length - 1 || side === \"backward\") {\n          roads.line.strings.push([\n            vectors.laneBottomRight(lane, road),\n            vectors.laneTopRight(lane, road),\n          ]);\n        }\n      }\n\n      //-----CENTER---- strings//\n      if (indexRoad === 0) {\n        roads.center.string = pointsToString([\n          {\n            letter: \"M\",\n            coords: [vectors.roadBottomLeft(road)],\n          },\n        ]);\n      }\n      roads.center.string += pointsToString([\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomLeft(road), vectors.roadBottomRight(road)],\n        },\n      ]);\n\n      //-----CURB----- strings//\n      if (indexRoad === 0) {\n        roads.curb.string = pointsToString([\n          {\n            letter: \"M\",\n            coords: [vectors.roadBottomLeft(road)],\n          },\n        ]);\n      }\n      roads.curb.string += pointsToString([\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomLeft(road), vectors.roadTopLeft(road)],\n        },\n        {\n          letter: \"M\",\n          coords: [vectors.roadTopRight(road)],\n        },\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomRight(road)],\n        },\n      ]);\n      if (indexRoad === points.length - 1) {\n        roads.curb.string += pointsToString([\n          {\n            letter: \"L\",\n            coords: [vectors.roadBottomLeft(points[0])],\n          },\n        ]);\n      }\n\n      //----ASPHALT---- elements//\n      roads.asphalt.elements[side] = roads.asphalt.strings[\n        side\n      ].map((lane, index) => (\n        <path d={lane} key={index} className={side + \"-asphalt\"} />\n      ));\n\n      //-----DEBUG----- elements//\n      roads.debug.elements[side] = roads.debug.strings[\n        side\n      ].map((coords, index) => (\n        <line\n          x1={coords[0].x}\n          y1={coords[0].y}\n          x2={coords[1].x}\n          y2={coords[1].y}\n          key={index}\n          className={side + \"-debug\"}\n        />\n      ));\n\n      //-----LINE------ elements//\n      roads.line.elements = roads.line.strings.map((coords, index) => (\n        <line\n          x1={coords[0].x}\n          y1={coords[0].y}\n          x2={coords[1].x}\n          y2={coords[1].y}\n          key={index}\n          className={side + \"-line\"}\n          stroke-dasharray=\"30, 60\"\n        />\n      ));\n    }\n  }\n\n  //-----CENTER---- elements//\n  roads.center.element = (\n    <path d={roads.center.string} className=\"center\" />\n  );\n\n  //-----CURB----- elements//\n  roads.curb.element = <path d={roads.curb.string} className=\"curb\"/>;\n\n  return roads;\n}\n","import { Typography } from \"@material-ui/core\";\nimport React, { useState, useEffect, useRef } from \"react\";\nimport { buildRoad } from \"./buildRoad\";\n\nexport function lenDeg(d, angle) {\n  const deg = (angle * Math.PI) / 180;\n  const x = d * Math.cos(deg);\n  const y = d * Math.sin(deg);\n  return { x, y };\n}\n\nexport function sumVector(a, b) {\n  const x = a.x + b.x;\n  const y = a.y + b.y;\n  return { x, y };\n}\n\nexport default function Artboard(props) {\n  /* svg ref */\n  const artboardRef = useRef();\n\n  const roadInfo = props.roadInfo;\n\n  const [coordInfo, setCoordInfo] = useState({});\n\n  useEffect(() => {\n    function changeCoordInfo() {\n      /* get coordinates of the svg element */\n      const newCoord = getCoordinateInfo(artboardRef, roadInfo);\n      /* sets state */\n      setCoordInfo(newCoord);\n    }\n\n    changeCoordInfo();\n    /* call getCoordinateInfo on every window change */\n    window.addEventListener(\"resize\", changeCoordInfo);\n\n    return () => {\n      window.removeEventListener(\"resize\", changeCoordInfo);\n    };\n  }, [artboardRef, roadInfo]);\n\n  /* get a list of all the road points */\n  const points = calculatePoints(roadInfo, coordInfo);\n\n  /* create elements based on road points */\n  const roads = buildRoad(points, coordInfo);\n\n  return (\n    <svg id=\"artboard\" ref={artboardRef}>\n      {roads ? roads.asphalt.elements.forward : null}\n      {roads ? roads.asphalt.elements.backward : null}\n      {/* {roads ? roads.debug.elements.forward : null}\n      {roads ? roads.debug.elements.backward : null} */}\n      {roads ? roads.center.element : null}\n      {roads ? roads.curb.element : null}\n      {roads ? roads.line.elements : null}\n      {!roads ? <Typography>Loading</Typography> : null}\n    </svg>\n  );\n}\n\nfunction getCoordinateInfo(element, roadInfo) {\n  if (!element.current) {\n    return null;\n  }\n\n  const clientRect = element.current.getBoundingClientRect();\n  const x = (clientRect.right - clientRect.left) / 2;\n  const y = (clientRect.bottom - clientRect.top) / 2;\n\n  const maxRoadWidth = Math.max.apply(\n    Math,\n    roadInfo.map((road) => {\n      return road.numberOfForward + road.numberOfBackward;\n    })\n  );\n  const windowBox = Math.min(x, y);\n  const roadLength = windowBox / 2;\n  const roadWidth = (windowBox / maxRoadWidth) * 0.5;\n\n  return { x, y, roadLength, roadWidth, maxRoadWidth };\n}\n\nfunction calculatePoints(roadInfo, coordInfo) {\n  const points = [];\n  /* coordinfo { x, y, roadLength, roadWidth, maxRoadWidth }; */\n  if (!(coordInfo && coordInfo.roadLength && coordInfo.roadWidth)) {\n    return null;\n  }\n\n  for (let i = 0; i < roadInfo.length; i++) {\n    const road = roadInfo[i];\n\n    points[i] = { forward: [], backward: [], angle: road.angle };\n\n    /* maxDistance = pixels from the center to the edge */\n    const maxDistance =\n      ((road.numberOfForward + road.numberOfBackward - 1) *\n        coordInfo.roadWidth) /\n      2;\n\n    const allLanes = road.numberOfForward + road.numberOfBackward;\n\n    for (let j = 0; j < allLanes; j++) {\n      let firstPoint = sumVector(\n        /* sum vector pointing east to get left or right */\n        lenDeg(maxDistance - j * coordInfo.roadWidth, road.angle - 90),\n        /* and the vector, responsible for making the center area */\n        lenDeg(coordInfo.maxRoadWidth * coordInfo.roadWidth * 0.8, road.angle)\n      );\n\n      let lastPoint = sumVector(\n        firstPoint,\n        lenDeg(coordInfo.roadLength, road.angle)\n      );\n\n      if (j >= road.numberOfBackward) {\n        points[i].forward.push({ first: firstPoint, last: lastPoint });\n      } else {\n        points[i].backward.push({ first: firstPoint, last: lastPoint });\n      }\n    }\n  }\n  return points;\n}\n","import React from \"react\";\nimport \"./App.css\";\n/* import { Typography } from \"@material-ui/core\";\nimport { useSpring, animated, config } from \"react-spring\";\nimport { useGesture } from \"react-use-gesture\"; */\nimport Artboard from \"./Artboard.js\";\n\n\nexport default function App() {\n  const roadInfo = [\n    {\n      numberOfForward: 1,\n      numberOfBackward: 1,\n      angle: 10,\n    },\n    {\n      numberOfForward: 1,\n      numberOfBackward: 1,\n      angle: 110,\n    },\n    {\n      numberOfForward: 2,\n      numberOfBackward: 2,\n      angle: 180,\n    },\n    {\n      numberOfForward: 1,\n      numberOfBackward: 1,\n      angle: 300,\n    },\n  ];\n  return (\n    <>\n      <Artboard roadInfo={roadInfo}/>\n      {/* <Solution />\n      <Inventory /> */}\n    </>\n  );\n}\n/* function Solution() {\n  return (\n    <Typography variant=\"body1\">\n      Solution\n      <br />\n    </Typography>\n  );\n}\n\nfunction Inventory() {\n  return (\n    <>\n      <Item />\n      <Item />\n    </>\n  );\n}\n\nfunction Item() {\n  const [{ x, y }, setSpring] = useSpring(() => ({\n    x: 0,\n    y: 0,\n    config: config.stiff,\n  }));\n\n  const [isClicking, setIsClicking] = useState(false);\n\n  const bind = useGesture({\n    onDrag: ({ down, movement: [mx, my] }) => {\n      setSpring({ x: down ? mx : 0, y: down ? my : 0 });\n      setIsClicking(!mx && !my);\n    },\n    onDragEnd: ({ event }) => {\n      if (isClicking) {\n        console.log(\"Click\");\n      } else {\n        console.log(\"Move\", event.x, event.y);\n      }\n    },\n  });\n\n  return <animated.div className=\"drag\" {...bind()} style={{ x, y }} />;\n}\n */\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}