{"version":3,"sources":["buildRoad.js","Artboard.js","App.js","index.js"],"names":["pointsToString","pointsArray","length","pathD","order","letter","coords","x","y","lenDeg","d","angle","deg","Math","PI","cos","sin","sumVector","a","b","Artboard","props","artboardRef","useRef","roadInfo","useState","coordInfo","setCoordInfo","useEffect","changeCoordInfo","newCoord","element","current","clientRect","getBoundingClientRect","right","left","bottom","top","maxRoadWidth","max","apply","map","road","numberOfForward","numberOfBackward","windowBox","min","roadLength","roadWidth","getCoordinateInfo","window","addEventListener","removeEventListener","roads","points","debug","elements","forward","backward","strings","asphalt","center","curb","vectors","offsetBottom","lane","first","offsetTop","last","halfRoadLeft","halfRoadRight","laneBottomLeft","laneTopLeft","laneBottomRight","laneTopRight","roadBottomLeft","roadBottomRight","roadTopLeft","roadTopRight","side","entries","index","push","string","className","x1","y1","x2","y2","buildRoad","i","maxDistance","allLanes","j","firstPoint","lastPoint","calculatePoints","id","ref","Typography","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.44f10add.chunk.js","sourcesContent":["import React from \"react\";\nimport { sumVector, lenDeg } from \"./Artboard\";\n\nfunction pointsToString(pointsArray) {\n  if (!(pointsArray && pointsArray.length)) {\n    return null;\n  }\n\n  let pathD = \"\";\n\n  for (const order of pointsArray) {\n    pathD += order.letter + \" \";\n\n    if (order.coords) {\n      for (const coords of order.coords) {\n        pathD += coords.x + \" \" + coords.y + \" \";\n      }\n    }\n  }\n  return pathD;\n}\n\nexport function buildRoad(points, coordInfo) {\n  if (!(points && coordInfo)) {\n    return null;\n  }\n\n  const roads = {\n    debug: {\n      elements: { forward: [], backward: [] },\n      strings: { forward: [], backward: [] },\n    },\n    asphalt: {\n      elements: { forward: [], backward: [] },\n      strings: { forward: [], backward: [] },\n    },\n    center: {},\n    curb: {},\n  };\n\n  const vectors = {\n    offsetBottom: (lane) => sumVector(coordInfo, lane.first),\n\n    offsetTop: (lane) => sumVector(coordInfo, lane.last),\n\n    halfRoadLeft: (road) => lenDeg(coordInfo.roadWidth / 2, road.angle - 90),\n\n    halfRoadRight: (road) => lenDeg(coordInfo.roadWidth / 2, road.angle + 90),\n\n    laneBottomLeft: (lane, road) =>\n      sumVector(vectors.halfRoadLeft(road), vectors.offsetBottom(lane)),\n\n    laneTopLeft: (lane, road) =>\n      sumVector(vectors.halfRoadLeft(road), vectors.offsetTop(lane)),\n\n    laneBottomRight: (lane, road) =>\n      sumVector(vectors.halfRoadRight(road), vectors.offsetBottom(lane)),\n\n    laneTopRight: (lane, road) =>\n      sumVector(vectors.halfRoadRight(road), vectors.offsetTop(lane)),\n\n    roadBottomLeft: (road) =>\n      sumVector(\n        sumVector(road.backward[0].first, coordInfo),\n        vectors.halfRoadLeft(road)\n      ),\n\n    roadBottomRight: (road) =>\n      sumVector(\n        sumVector(road.forward[road.forward.length - 1].first, coordInfo),\n        vectors.halfRoadRight(road)\n      ),\n    roadTopLeft: (road) =>\n      sumVector(\n        sumVector(road.backward[0].last, coordInfo),\n        vectors.halfRoadLeft(road)\n      ),\n\n    roadTopRight: (road) =>\n      sumVector(\n        sumVector(road.forward[road.forward.length - 1].last, coordInfo),\n        vectors.halfRoadRight(road)\n      ),\n  };\n  for (const side of [\"forward\", \"backward\"]) {\n    // fill both sides of the object\n    for (const [index, road] of points.entries()) {\n      // for every road\n\n      for (const lane of road[side]) {\n        // for every lane\n\n        //----ASPHALT---- strings//\n        roads.asphalt.strings[side].push(\n          pointsToString([\n            { letter: \"M\", coords: [vectors.offsetBottom(lane)] },\n            {\n              letter: \"L\",\n              coords: [\n                vectors.laneBottomLeft(lane, road),\n                vectors.laneTopLeft(lane, road),\n                vectors.laneTopRight(lane, road),\n                vectors.laneBottomRight(lane, road),\n              ],\n            },\n            { letter: \"Z\" },\n          ])\n        );\n\n        //-----DEBUG----- strings//\n        roads.debug.strings[side].push([\n          vectors.offsetBottom(lane),\n          vectors.offsetTop(lane),\n        ]);\n      }\n\n      //-----CENTER---- strings//\n      if (index === 0) {\n        roads.center.string = pointsToString([\n          {\n            letter: \"M\",\n            coords: [vectors.roadBottomLeft(road)],\n          },\n        ]);\n      }\n      roads.center.string += pointsToString([\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomLeft(road), vectors.roadBottomRight(road)],\n        },\n      ]);\n\n      //-----CURB----- strings//\n      if (index === 0) {\n        roads.curb.string = pointsToString([\n          {\n            letter: \"M\",\n            coords: [vectors.roadBottomLeft(road)],\n          },\n        ]);\n      }\n      roads.curb.string += pointsToString([\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomLeft(road), vectors.roadTopLeft(road)],\n        },\n        {\n          letter: \"M\",\n          coords: [vectors.roadTopRight(road)],\n        },\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomRight(road)],\n        },\n      ]);\n\n      //----ASPHALT---- elements//\n      roads.asphalt.elements[side] = roads.asphalt.strings[\n        side\n      ].map((lane, index) => (\n        <path d={lane} key={index} className={side + \"-asphalt\"} />\n      ));\n\n      //-----DEBUG----- elements//\n      roads.debug.elements[side] = roads.debug.strings[\n        side\n      ].map((coords, index) => (\n        <line\n          x1={coords[0].x}\n          y1={coords[0].y}\n          x2={coords[1].x}\n          y2={coords[1].y}\n          key={index}\n          className={side + \"-debug\"}\n        />\n      ));\n    }\n  }\n\n  //-----CENTER---- elements//\n  roads.center.element = (\n    <path d={roads.center.string} className=\"forward-asphalt\" />\n  );\n\n  //-----CURB----- elements//\n  roads.curb.element = (\n    <path d={roads.curb.string} className=\"forward-debug\" />\n  );\n\n  return roads;\n}\n","import { Typography } from \"@material-ui/core\";\nimport React, { useState, useEffect, useRef } from \"react\";\nimport { buildRoad } from \"./buildRoad\";\n\nexport function lenDeg(d, angle) {\n  const deg = (angle * Math.PI) / 180;\n  const x = d * Math.cos(deg);\n  const y = d * Math.sin(deg);\n  return { x, y };\n}\n\nexport function sumVector(a, b) {\n  const x = a.x + b.x;\n  const y = a.y + b.y;\n  return { x, y };\n}\n\nexport default function Artboard(props) {\n  /* svg ref */\n  const artboardRef = useRef();\n\n  const roadInfo = props.roadInfo;\n\n  const [coordInfo, setCoordInfo] = useState({});\n\n  useEffect(() => {\n    function changeCoordInfo() {\n      /* get coordinates of the svg element */\n      const newCoord = getCoordinateInfo(artboardRef, roadInfo);\n      /* sets state */\n      setCoordInfo(newCoord);\n    }\n\n    changeCoordInfo();\n    /* call getCoordinateInfo on every window change */\n    window.addEventListener(\"resize\", changeCoordInfo);\n\n    return () => {\n      window.removeEventListener(\"resize\", changeCoordInfo);\n    };\n  }, [artboardRef, roadInfo]);\n\n  /* get a list of all the road points */\n  const points = calculatePoints(roadInfo, coordInfo);\n\n  /* create elements based on road points */\n  const roads = buildRoad(points, coordInfo);\n\n  return (\n    <svg id=\"artboard\" ref={artboardRef}>\n      {roads ? roads.asphalt.elements.forward : null}\n      {roads ? roads.asphalt.elements.backward : null}\n      {roads ? roads.debug.elements.forward : null}\n      {roads ? roads.debug.elements.backward : null}\n      {roads ? roads.center.element : null}\n      {roads ? roads.curb.element : null}\n      {!roads ? <Typography>Loading</Typography> : null}\n    </svg>\n  );\n}\n\nfunction getCoordinateInfo(element, roadInfo) {\n  if (!element.current) {\n    return null;\n  }\n\n  const clientRect = element.current.getBoundingClientRect();\n  const x = (clientRect.right - clientRect.left) / 2;\n  const y = (clientRect.bottom - clientRect.top) / 2;\n\n  const maxRoadWidth = Math.max.apply(\n    Math,\n    roadInfo.map((road) => {\n      return road.numberOfForward + road.numberOfBackward;\n    })\n  );\n  const windowBox = Math.min(x, y);\n  const roadLength = windowBox / 2;\n  const roadWidth = (windowBox / maxRoadWidth) * 0.5;\n\n  return { x, y, roadLength, roadWidth, maxRoadWidth };\n}\n\nfunction calculatePoints(roadInfo, coordInfo) {\n  const points = [];\n  /* coordinfo { x, y, roadLength, roadWidth, maxRoadWidth }; */\n  if (!(coordInfo && coordInfo.roadLength && coordInfo.roadWidth)) {\n    return null;\n  }\n\n  for (let i = 0; i < roadInfo.length; i++) {\n    const road = roadInfo[i];\n\n    points[i] = { forward: [], backward: [], angle: road.angle };\n\n    /* maxDistance = pixels from the center to the edge */\n    const maxDistance =\n      ((road.numberOfForward + road.numberOfBackward - 1) *\n        coordInfo.roadWidth) /\n      2;\n\n    const allLanes = road.numberOfForward + road.numberOfBackward;\n\n    for (let j = 0; j < allLanes; j++) {\n      let firstPoint = sumVector(\n        /* sum vector pointing east to get left or right */\n        lenDeg(maxDistance - j * coordInfo.roadWidth, road.angle - 90),\n        /* and the vector, responsible for making the center area */\n        lenDeg(coordInfo.maxRoadWidth * coordInfo.roadWidth * 0.8, road.angle)\n      );\n\n      let lastPoint = sumVector(\n        firstPoint,\n        lenDeg(coordInfo.roadLength, road.angle)\n      );\n\n      if (j >= road.numberOfBackward) {\n        points[i].forward.push({ first: firstPoint, last: lastPoint });\n      } else {\n        points[i].backward.push({ first: firstPoint, last: lastPoint });\n      }\n    }\n  }\n  return points;\n}\n","import React from \"react\";\nimport \"./App.css\";\n/* import { Typography } from \"@material-ui/core\";\nimport { useSpring, animated, config } from \"react-spring\";\nimport { useGesture } from \"react-use-gesture\"; */\nimport Artboard from \"./Artboard.js\";\n\n\nexport default function App() {\n  const roadInfo = [\n    {\n      numberOfForward: 1,\n      numberOfBackward: 1,\n      angle: 10,\n    },\n    {\n      numberOfForward: 1,\n      numberOfBackward: 1,\n      angle: 110,\n    },\n    {\n      numberOfForward: 2,\n      numberOfBackward: 2,\n      angle: 180,\n    },\n    {\n      numberOfForward: 1,\n      numberOfBackward: 1,\n      angle: 300,\n    },\n  ];\n  return (\n    <>\n      <Artboard roadInfo={roadInfo}/>\n      {/* <Solution />\n      <Inventory /> */}\n    </>\n  );\n}\n/* function Solution() {\n  return (\n    <Typography variant=\"body1\">\n      Solution\n      <br />\n    </Typography>\n  );\n}\n\nfunction Inventory() {\n  return (\n    <>\n      <Item />\n      <Item />\n    </>\n  );\n}\n\nfunction Item() {\n  const [{ x, y }, setSpring] = useSpring(() => ({\n    x: 0,\n    y: 0,\n    config: config.stiff,\n  }));\n\n  const [isClicking, setIsClicking] = useState(false);\n\n  const bind = useGesture({\n    onDrag: ({ down, movement: [mx, my] }) => {\n      setSpring({ x: down ? mx : 0, y: down ? my : 0 });\n      setIsClicking(!mx && !my);\n    },\n    onDragEnd: ({ event }) => {\n      if (isClicking) {\n        console.log(\"Click\");\n      } else {\n        console.log(\"Move\", event.x, event.y);\n      }\n    },\n  });\n\n  return <animated.div className=\"drag\" {...bind()} style={{ x, y }} />;\n}\n */\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}