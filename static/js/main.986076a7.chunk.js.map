{"version":3,"sources":["buildRoad.js","Artboard.js","App.js","index.js"],"names":["pointsToString","pointsArray","length","pathD","order","letter","coords","x","y","Artboard","props","artboardRef","useRef","useState","coordInfo","setCoordInfo","numberOfBackward","numberOfForward","angle","roadInfo","setRoadInfo","rotate","useGesture","onDrag","event","index","args","console","log","newPoint","sumVector","a","k","multVector","deg","Math","atan2","PI","newRoadInfo","map","useEffect","changeCoordInfo","newCoord","element","current","clientRect","getBoundingClientRect","right","left","bottom","top","maxRoadWidth","max","apply","road","windowBox","min","roadLength","roadWidth","getCoordinateInfo","window","addEventListener","removeEventListener","roads","points","debug","elements","forward","backward","strings","asphalt","line","striped","continous","center","curb","vectors","offsetBottom","lane","first","offsetTop","last","halfRoadLeft","lenDeg","halfRoadRight","laneBottomLeft","laneTopLeft","laneBottomRight","laneTopRight","roadBottomLeft","roadBottomRight","roadTopLeft","roadTopRight","roadTopMiddle","side","entries","indexRoad","indexLane","push","cx","cy","r","className","string","d","x1","y1","x2","y2","strokeDasharray","buildRoad","i","maxDistance","allLanes","j","firstPoint","lastPoint","calculatePoints","id","ref","cos","sin","b","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.986076a7.chunk.js","sourcesContent":["import React from \"react\";\nimport { sumVector, lenDeg } from \"./Artboard\";\n\nfunction pointsToString(pointsArray) {\n  if (!(pointsArray && pointsArray.length)) {\n    return null;\n  }\n\n  let pathD = \"\";\n\n  for (const order of pointsArray) {\n    pathD += order.letter + \" \";\n\n    if (order.coords) {\n      for (const coords of order.coords) {\n        pathD += coords.x + \" \" + coords.y + \" \";\n      }\n    }\n  }\n  return pathD;\n}\n\nexport function buildRoad(points, coordInfo, rotate) {\n  if (!(points && coordInfo)) {\n    return null;\n  }\n\n  const roads = {\n    debug: {\n      elements: { forward: [], backward: [] },\n      strings: { forward: [], backward: [] },\n    },\n    asphalt: {\n      elements: { forward: [], backward: [] },\n      strings: { forward: [], backward: [] },\n    },\n    line: {\n      elements: { striped: [], continous: [] },\n      strings: { striped: [], continous: [] },\n    },\n    center: {},\n    curb: {},\n    rotate: { elements: [], strings: [] },\n  };\n\n  const vectors = {\n    offsetBottom: (lane) => sumVector(coordInfo, lane.first),\n\n    offsetTop: (lane) => sumVector(coordInfo, lane.last),\n\n    halfRoadLeft: (road) => lenDeg(coordInfo.roadWidth / 2, road.angle - 90),\n\n    halfRoadRight: (road) => lenDeg(coordInfo.roadWidth / 2, road.angle + 90),\n\n    laneBottomLeft: (lane, road) =>\n      sumVector(vectors.halfRoadLeft(road), vectors.offsetBottom(lane)),\n\n    laneTopLeft: (lane, road) =>\n      sumVector(vectors.halfRoadLeft(road), vectors.offsetTop(lane)),\n\n    laneBottomRight: (lane, road) =>\n      sumVector(vectors.halfRoadRight(road), vectors.offsetBottom(lane)),\n\n    laneTopRight: (lane, road) =>\n      sumVector(vectors.halfRoadRight(road), vectors.offsetTop(lane)),\n\n    roadBottomLeft: (road) =>\n      sumVector(\n        sumVector(road.backward[0].first, coordInfo),\n        vectors.halfRoadLeft(road)\n      ),\n\n    roadBottomRight: (road) =>\n      sumVector(\n        sumVector(road.forward[road.forward.length - 1].first, coordInfo),\n        vectors.halfRoadRight(road)\n      ),\n    roadTopLeft: (road) =>\n      sumVector(\n        sumVector(road.backward[0].last, coordInfo),\n        vectors.halfRoadLeft(road)\n      ),\n\n    roadTopRight: (road) =>\n      sumVector(\n        sumVector(road.forward[road.forward.length - 1].last, coordInfo),\n        vectors.halfRoadRight(road)\n      ),\n\n    roadTopMiddle: (road) =>\n      sumVector(\n        lenDeg(coordInfo.roadLength, road.angle),\n        sumVector(\n          lenDeg(\n            ((road.numberOfForward + road.numberOfBackward) *\n              coordInfo.roadWidth) /\n              2,\n            road.angle + 90\n          ),\n          vectors.roadBottomLeft(road)\n        )\n      ),\n  };\n  for (const side of [\"forward\", \"backward\"]) {\n    // fill both sides of the object\n    for (const [indexRoad, road] of points.entries()) {\n      // for every road\n\n      for (const [indexLane, lane] of road[side].entries()) {\n        // for every lane\n\n        //----ASPHALT---- strings//\n        roads.asphalt.strings[side].push(\n          pointsToString([\n            { letter: \"M\", coords: [vectors.offsetBottom(lane)] },\n            {\n              letter: \"L\",\n              coords: [\n                vectors.laneBottomLeft(lane, road),\n                vectors.laneTopLeft(lane, road),\n                vectors.laneTopRight(lane, road),\n                vectors.laneBottomRight(lane, road),\n              ],\n            },\n            { letter: \"Z\" },\n          ])\n        );\n\n        //-----DEBUG----- strings//\n        roads.debug.strings[side].push([\n          vectors.offsetBottom(lane),\n          vectors.offsetTop(lane),\n        ]);\n\n        //-----LINE------ strings//\n        if (indexLane !== road[side].length - 1 || side === \"backward\") {\n          if (indexLane === road[side].length - 1 && side === \"backward\") {\n            roads.line.strings.continous.push([\n              vectors.laneBottomRight(lane, road),\n              vectors.laneTopRight(lane, road),\n            ]);\n          } else {\n            roads.line.strings.striped.push([\n              vectors.laneBottomRight(lane, road),\n              vectors.laneTopRight(lane, road),\n            ]);\n          }\n        }\n      }\n\n      //-----ROTATE---- strings//\n      if (side === \"backward\") {\n        roads.rotate.strings.push(vectors.roadTopMiddle(road));\n        roads.rotate.elements = roads.rotate.strings.map((coords, index) => (\n          <circle\n            cx={coords.x}\n            cy={coords.y}\n            r=\"10\"\n            key={index}\n            {...rotate(index)}\n            className=\"rotate\"\n          />\n        ));\n      }\n\n      //-----CENTER---- strings//\n      if (indexRoad === 0) {\n        roads.center.string = pointsToString([\n          {\n            letter: \"M\",\n            coords: [vectors.roadBottomLeft(road)],\n          },\n        ]);\n      }\n      roads.center.string += pointsToString([\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomLeft(road), vectors.roadBottomRight(road)],\n        },\n      ]);\n\n      roads.coordInfo = <circle cx={coordInfo.x} cy={coordInfo.y} r=\"5\" />;\n\n      //-----CURB----- strings//\n      if (indexRoad === 0) {\n        roads.curb.string = pointsToString([\n          {\n            letter: \"M\",\n            coords: [vectors.roadBottomLeft(road)],\n          },\n        ]);\n      }\n      roads.curb.string += pointsToString([\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomLeft(road), vectors.roadTopLeft(road)],\n        },\n        {\n          letter: \"M\",\n          coords: [vectors.roadTopRight(road)],\n        },\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomRight(road)],\n        },\n      ]);\n      if (indexRoad === points.length - 1) {\n        roads.curb.string += pointsToString([\n          {\n            letter: \"L\",\n            coords: [vectors.roadBottomLeft(points[0])],\n          },\n        ]);\n      }\n\n      //----ASPHALT---- elements//\n      roads.asphalt.elements[side] = roads.asphalt.strings[\n        side\n      ].map((lane, index) => (\n        <path d={lane} key={index} className={side + \"-asphalt\"} />\n      ));\n\n      //-----DEBUG----- elements//\n      roads.debug.elements[side] = roads.debug.strings[\n        side\n      ].map((coords, index) => (\n        <line\n          x1={coords[0].x}\n          y1={coords[0].y}\n          x2={coords[1].x}\n          y2={coords[1].y}\n          key={index}\n          className={side + \"-debug\"}\n        />\n      ));\n\n      //-----LINE------ elements//\n      roads.line.elements.striped = roads.line.strings.striped.map(\n        (coords, index) => (\n          <line\n            x1={coords[0].x}\n            y1={coords[0].y}\n            x2={coords[1].x}\n            y2={coords[1].y}\n            key={index}\n            className={side + \"-line\"}\n            strokeDasharray=\"30, 60\"\n          />\n        )\n      );\n      roads.line.elements.continous = roads.line.strings.continous.map(\n        (coords, index) => (\n          <line\n            x1={coords[0].x}\n            y1={coords[0].y}\n            x2={coords[1].x}\n            y2={coords[1].y}\n            key={index}\n            className={side + \"-line\"}\n          />\n        )\n      );\n    }\n  }\n\n  //-----CENTER---- elements//\n  roads.center.element = <path d={roads.center.string} className=\"center\" />;\n\n  //-----CURB----- elements//\n  roads.curb.element = <path d={roads.curb.string} className=\"curb\" />;\n\n  return roads;\n}\n","import React, { useState, useEffect, useRef } from \"react\";\nimport { useGesture } from \"react-use-gesture\";\nimport { buildRoad } from \"./buildRoad\";\n\nexport default function Artboard(props) {\n  /* svg ref */\n  const artboardRef = useRef();\n\n  const [coordInfo, setCoordInfo] = useState({});\n\n  const [roadInfo, setRoadInfo] = useState([\n    {\n      numberOfBackward: 1,\n      numberOfForward: 2,\n      angle: 0,\n    },\n    {\n      numberOfBackward: 1,\n      numberOfForward: 1,\n      angle: 110,\n    },\n    {\n      numberOfBackward: 2,\n      numberOfForward: 3,\n      angle: 170,\n    },\n    {\n      numberOfBackward: 1,\n      numberOfForward: 1,\n      angle: 300,\n    },\n  ]);\n\n  const rotate = useGesture({\n    onDrag: ({ event, args: [index] }) => {\n      console.log(\"dragging!\")\n      if (event.x && event.y) {\n        const newPoint = sumVector(event, multVector(coordInfo, -1));\n        const newAngle = Math.atan2(newPoint.y, newPoint.x);\n        const deg = newAngle * (180 / Math.PI);\n\n        // shallow copy\n        const newRoadInfo = roadInfo.map((a) => ({ ...a }));\n        newRoadInfo[index].angle = deg;\n\n        setRoadInfo(newRoadInfo);\n      }\n    },\n  });\n\n  useEffect(() => {\n    function changeCoordInfo() {\n      /* get coordinates of the svg element */\n      const newCoord = getCoordinateInfo(artboardRef, roadInfo);\n      /* sets state */\n      setCoordInfo(newCoord);\n    }\n\n    changeCoordInfo();\n    /* call getCoordinateInfo on every window change */\n    window.addEventListener(\"resize\", changeCoordInfo);\n\n    return () => {\n      window.removeEventListener(\"resize\", changeCoordInfo);\n    };\n  }, [artboardRef, roadInfo]);\n\n  /* get a list of all the road points */\n  const points = calculatePoints(roadInfo, coordInfo);\n\n  /* create elements based on road points */\n  const roads = buildRoad(points, coordInfo, rotate);\n\n  return (\n    <svg id=\"artboard\" ref={artboardRef}>\n      {roads ? roads.asphalt.elements.forward : null}\n      {roads ? roads.asphalt.elements.backward : null}\n      {/* {roads ? roads.debug.elements.forward : null}\n      {roads ? roads.debug.elements.backward : null} */}\n      {roads ? roads.center.element : null}\n      {roads ? roads.curb.element : null}\n      {roads ? roads.line.elements.continous : null}\n      {roads ? roads.line.elements.striped : null}\n      {roads ? roads.rotate.elements : null}\n      {roads ? roads.coordInfo : null}\n      {!roads ? <text>Loading</text> : null}\n    </svg>\n  );\n}\n\nfunction calculatePoints(roadInfo, coordInfo) {\n  const points = [];\n\n  if (!(coordInfo && coordInfo.roadLength && coordInfo.roadWidth)) {\n    return null;\n  }\n\n  for (let i = 0; i < roadInfo.length; i++) {\n    const road = roadInfo[i];\n\n    /* maxDistance = pixels from the center to the edge */\n    const maxDistance =\n      ((road.numberOfForward + road.numberOfBackward - 1) *\n        coordInfo.roadWidth) /\n      2;\n    points[i] = {\n      forward: [],\n      backward: [],\n      maxDistance,\n      angle: road.angle,\n      numberOfForward: road.numberOfForward,\n      numberOfBackward: road.numberOfBackward,\n    };\n\n    const allLanes = road.numberOfForward + road.numberOfBackward;\n\n    for (let j = 0; j < allLanes; j++) {\n      let firstPoint = sumVector(\n        /* sum vector pointing east to get left or right */\n        lenDeg(maxDistance - j * coordInfo.roadWidth, road.angle - 90),\n        /* and the vector, responsible for making the center area */\n        lenDeg(coordInfo.maxRoadWidth * coordInfo.roadWidth * 0.8, road.angle)\n      );\n\n      let lastPoint = sumVector(\n        firstPoint,\n        lenDeg(coordInfo.roadLength, road.angle)\n      );\n\n      if (j >= road.numberOfForward) {\n        points[i].forward.push({ first: firstPoint, last: lastPoint });\n      } else {\n        points[i].backward.push({ first: firstPoint, last: lastPoint });\n      }\n    }\n  }\n  return points;\n}\n\nexport function lenDeg(d, angle) {\n  const deg = (angle * Math.PI) / 180;\n  const x = d * Math.cos(deg);\n  const y = d * Math.sin(deg);\n  return { x, y };\n}\n\nexport function sumVector(a, b) {\n  const x = a.x + b.x;\n  const y = a.y + b.y;\n  return { x, y };\n}\n\nfunction multVector(a, k) {\n  const x = a.x * k;\n  const y = a.y * k;\n  return { x, y };\n}\n\nexport function getCoordinateInfo(element, roadInfo) {\n  if (!element.current) {\n    return null;\n  }\n\n  const clientRect = element.current.getBoundingClientRect();\n  const x = (clientRect.right - clientRect.left) / 2;\n  const y = (clientRect.bottom - clientRect.top) / 2;\n\n  const maxRoadWidth = Math.max.apply(\n    Math,\n    roadInfo.map((road) => {\n      return road.numberOfForward + road.numberOfBackward;\n    })\n  );\n  const windowBox = Math.min(x, y);\n  const roadLength = windowBox / 2;\n  const roadWidth = (windowBox / maxRoadWidth) * 0.4;\n\n  return { x, y, roadLength, roadWidth, maxRoadWidth };\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport Artboard from \"./Artboard.js\";\n\nexport default function App() {\n  return (\n    <>\n      <Artboard />\n      {/* <Solution />\n      <Inventory /> */}\n    </>\n  );\n}\n/* function Solution() {\n  return (\n    <Typography variant=\"body1\">\n      Solution\n      <br />\n    </Typography>\n  );\n}\n\nfunction Inventory() {\n  return (\n    <>\n      <Item />\n      <Item />\n    </>\n  );\n}\n\nfunction Item() {\n  const [{ x, y }, setSpring] = useSpring(() => ({\n    x: 0,\n    y: 0,\n    config: config.stiff,\n  }));\n\n  const [isClicking, setIsClicking] = useState(false);\n\n  const bind = useGesture({\n    onDrag: ({ down, movement: [mx, my] }) => {\n      setSpring({ x: down ? mx : 0, y: down ? my : 0 });\n      setIsClicking(!mx && !my);\n    },\n    onDragEnd: ({ event }) => {\n      if (isClicking) {\n        console.log(\"Click\");\n      } else {\n        console.log(\"Move\", event.x, event.y);\n      }\n    },\n  });\n\n  return <animated.div className=\"drag\" {...bind()} style={{ x, y }} />;\n}\n */\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}