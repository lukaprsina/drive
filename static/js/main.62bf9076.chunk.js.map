{"version":3,"sources":["buildRoad.js","Artboard.js","App.js","index.js"],"names":["pointsToString","pointsArray","length","pathD","order","letter","coords","x","y","lenDeg","d","angle","deg","Math","PI","cos","sin","sumVector","a","b","Artboard","props","artboardRef","useRef","roadInfo","useState","coordInfo","setCoordInfo","useEffect","changeCoordInfo","newCoord","element","current","clientRect","getBoundingClientRect","right","left","bottom","top","maxRoadWidth","max","apply","map","road","numberOfForward","numberOfBackward","windowBox","min","roadLength","roadWidth","getCoordinateInfo","window","addEventListener","removeEventListener","roads","points","debug","elements","forward","backward","strings","asphalt","line","striped","continous","center","curb","vectors","offsetBottom","lane","first","offsetTop","last","halfRoadLeft","halfRoadRight","laneBottomLeft","laneTopLeft","laneBottomRight","laneTopRight","roadBottomLeft","roadBottomRight","roadTopLeft","roadTopRight","side","entries","indexRoad","indexLane","push","string","index","className","x1","y1","x2","y2","strokeDasharray","buildRoad","i","maxDistance","allLanes","j","firstPoint","lastPoint","calculatePoints","id","ref","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.62bf9076.chunk.js","sourcesContent":["import React from \"react\";\nimport { sumVector, lenDeg } from \"./Artboard\";\n\nfunction pointsToString(pointsArray) {\n  if (!(pointsArray && pointsArray.length)) {\n    return null;\n  }\n\n  let pathD = \"\";\n\n  for (const order of pointsArray) {\n    pathD += order.letter + \" \";\n\n    if (order.coords) {\n      for (const coords of order.coords) {\n        pathD += coords.x + \" \" + coords.y + \" \";\n      }\n    }\n  }\n  return pathD;\n}\n\nexport function buildRoad(points, coordInfo) {\n  if (!(points && coordInfo)) {\n    return null;\n  }\n\n  const roads = {\n    debug: {\n      elements: { forward: [], backward: [] },\n      strings: { forward: [], backward: [] },\n    },\n    asphalt: {\n      elements: { forward: [], backward: [] },\n      strings: { forward: [], backward: [] },\n    },\n    line: {\n      elements: { striped: [], continous: [] },\n      strings: { striped: [], continous: [] },\n    },\n    center: {},\n    curb: {},\n  };\n\n  const vectors = {\n    offsetBottom: (lane) => sumVector(coordInfo, lane.first),\n\n    offsetTop: (lane) => sumVector(coordInfo, lane.last),\n\n    halfRoadLeft: (road) => lenDeg(coordInfo.roadWidth / 2, road.angle - 90),\n\n    halfRoadRight: (road) => lenDeg(coordInfo.roadWidth / 2, road.angle + 90),\n\n    laneBottomLeft: (lane, road) =>\n      sumVector(vectors.halfRoadLeft(road), vectors.offsetBottom(lane)),\n\n    laneTopLeft: (lane, road) =>\n      sumVector(vectors.halfRoadLeft(road), vectors.offsetTop(lane)),\n\n    laneBottomRight: (lane, road) =>\n      sumVector(vectors.halfRoadRight(road), vectors.offsetBottom(lane)),\n\n    laneTopRight: (lane, road) =>\n      sumVector(vectors.halfRoadRight(road), vectors.offsetTop(lane)),\n\n    roadBottomLeft: (\n      road //poglej kuk se to izrazi z 0 in length - 1\n    ) =>\n      sumVector(\n        sumVector(road.backward[0].first, coordInfo),\n        vectors.halfRoadLeft(road)\n      ),\n\n    roadBottomRight: (road) =>\n      sumVector(\n        sumVector(road.forward[road.forward.length - 1].first, coordInfo),\n        vectors.halfRoadRight(road)\n      ),\n    roadTopLeft: (road) =>\n      sumVector(\n        sumVector(road.backward[0].last, coordInfo),\n        vectors.halfRoadLeft(road)\n      ),\n\n    roadTopRight: (road) =>\n      sumVector(\n        sumVector(road.forward[road.forward.length - 1].last, coordInfo),\n        vectors.halfRoadRight(road)\n      ),\n  };\n  for (const side of [\"forward\", \"backward\"]) {\n    // fill both sides of the object\n    for (const [indexRoad, road] of points.entries()) {\n      // for every road\n\n      for (const [indexLane, lane] of road[side].entries()) {\n        // for every lane\n\n        //----ASPHALT---- strings//\n        roads.asphalt.strings[side].push(\n          pointsToString([\n            { letter: \"M\", coords: [vectors.offsetBottom(lane)] },\n            {\n              letter: \"L\",\n              coords: [\n                vectors.laneBottomLeft(lane, road),\n                vectors.laneTopLeft(lane, road),\n                vectors.laneTopRight(lane, road),\n                vectors.laneBottomRight(lane, road),\n              ],\n            },\n            { letter: \"Z\" },\n          ])\n        );\n\n        //-----DEBUG----- strings//\n        roads.debug.strings[side].push([\n          vectors.offsetBottom(lane),\n          vectors.offsetTop(lane),\n        ]);\n\n        //-----LINE------ strings//\n        if (indexLane !== road[side].length - 1 || side === \"backward\") {\n          if (indexLane === road[side].length - 1 && side === \"backward\") {\n            roads.line.strings.continous.push([\n              vectors.laneBottomRight(lane, road),\n              vectors.laneTopRight(lane, road),\n            ]);\n          } else {\n            roads.line.strings.striped.push([\n              vectors.laneBottomRight(lane, road),\n              vectors.laneTopRight(lane, road),\n            ]);\n          }\n        }\n      }\n\n      //-----CENTER---- strings//\n      if (indexRoad === 0) {\n        roads.center.string = pointsToString([\n          {\n            letter: \"M\",\n            coords: [vectors.roadBottomLeft(road)],\n          },\n        ]);\n      }\n      roads.center.string += pointsToString([\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomLeft(road), vectors.roadBottomRight(road)],\n        },\n      ]);\n\n      //-----CURB----- strings//\n      if (indexRoad === 0) {\n        roads.curb.string = pointsToString([\n          {\n            letter: \"M\",\n            coords: [vectors.roadBottomLeft(road)],\n          },\n        ]);\n      }\n      roads.curb.string += pointsToString([\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomLeft(road), vectors.roadTopLeft(road)],\n        },\n        {\n          letter: \"M\",\n          coords: [vectors.roadTopRight(road)],\n        },\n        {\n          letter: \"L\",\n          coords: [vectors.roadBottomRight(road)],\n        },\n      ]);\n      if (indexRoad === points.length - 1) {\n        roads.curb.string += pointsToString([\n          {\n            letter: \"L\",\n            coords: [vectors.roadBottomLeft(points[0])],\n          },\n        ]);\n      }\n\n      //----ASPHALT---- elements//\n      roads.asphalt.elements[side] = roads.asphalt.strings[\n        side\n      ].map((lane, index) => (\n        <path d={lane} key={index} className={side + \"-asphalt\"} />\n      ));\n\n      //-----DEBUG----- elements//\n      roads.debug.elements[side] = roads.debug.strings[\n        side\n      ].map((coords, index) => (\n        <line\n          x1={coords[0].x}\n          y1={coords[0].y}\n          x2={coords[1].x}\n          y2={coords[1].y}\n          key={index}\n          className={side + \"-debug\"}\n        />\n      ));\n\n      //-----LINE------ elements//\n      roads.line.elements.striped = roads.line.strings.striped.map((coords, index) => (\n        <line\n          x1={coords[0].x}\n          y1={coords[0].y}\n          x2={coords[1].x}\n          y2={coords[1].y}\n          key={index}\n          className={side + \"-line\"}\n          strokeDasharray=\"30, 60\"\n        />\n      ));\n      roads.line.elements.continous = roads.line.strings.continous.map((coords, index) => (\n        <line\n          x1={coords[0].x}\n          y1={coords[0].y}\n          x2={coords[1].x}\n          y2={coords[1].y}\n          key={index}\n          className={side + \"-line\"}\n        />\n      ));\n    }\n  }\n\n  //-----CENTER---- elements//\n  roads.center.element = <path d={roads.center.string} className=\"center\" />;\n\n  //-----CURB----- elements//\n  roads.curb.element = <path d={roads.curb.string} className=\"curb\" />;\n\n  return roads;\n}\n","import React, { useState, useEffect, useRef } from \"react\";\nimport { buildRoad } from \"./buildRoad\";\n\nexport function lenDeg(d, angle) {\n  const deg = (angle * Math.PI) / 180;\n  const x = d * Math.cos(deg);\n  const y = d * Math.sin(deg);\n  return { x, y };\n}\n\nexport function sumVector(a, b) {\n  const x = a.x + b.x;\n  const y = a.y + b.y;\n  return { x, y };\n}\n\nexport default function Artboard(props) {\n  /* svg ref */\n  const artboardRef = useRef();\n\n  const roadInfo = props.roadInfo;\n\n  const [coordInfo, setCoordInfo] = useState({});\n\n  useEffect(() => {\n    function changeCoordInfo() {\n      /* get coordinates of the svg element */\n      const newCoord = getCoordinateInfo(artboardRef, roadInfo);\n      /* sets state */\n      setCoordInfo(newCoord);\n    }\n\n    changeCoordInfo();\n    /* call getCoordinateInfo on every window change */\n    window.addEventListener(\"resize\", changeCoordInfo);\n\n    return () => {\n      window.removeEventListener(\"resize\", changeCoordInfo);\n    };\n  }, [artboardRef, roadInfo]);\n\n  /* get a list of all the road points */\n  const points = calculatePoints(roadInfo, coordInfo);\n\n  /* create elements based on road points */\n  const roads = buildRoad(points, coordInfo);\n\n  return (\n    <svg id=\"artboard\" ref={artboardRef}>\n      {roads ? roads.asphalt.elements.forward : null}\n      {roads ? roads.asphalt.elements.backward : null}\n      {/* {roads ? roads.debug.elements.forward : null}\n      {roads ? roads.debug.elements.backward : null} */}\n      {roads ? roads.center.element : null}\n      {roads ? roads.curb.element : null}\n      {roads ? roads.line.elements.continous : null}\n      {roads ? roads.line.elements.striped : null}\n      {!roads ? <text>Loading</text> : null}\n    </svg>\n  );\n}\n\nfunction getCoordinateInfo(element, roadInfo) {\n  if (!element.current) {\n    return null;\n  }\n\n  const clientRect = element.current.getBoundingClientRect();\n  const x = (clientRect.right - clientRect.left) / 2;\n  const y = (clientRect.bottom - clientRect.top) / 2;\n\n  const maxRoadWidth = Math.max.apply(\n    Math,\n    roadInfo.map((road) => {\n      return road.numberOfForward + road.numberOfBackward;\n    })\n  );\n  const windowBox = Math.min(x, y);\n  const roadLength = windowBox / 2;\n  const roadWidth = (windowBox / maxRoadWidth) * 0.5;\n\n  return { x, y, roadLength, roadWidth, maxRoadWidth };\n}\n\nfunction calculatePoints(roadInfo, coordInfo) {\n  const points = [];\n  /* coordinfo { x, y, roadLength, roadWidth, maxRoadWidth }; */\n  if (!(coordInfo && coordInfo.roadLength && coordInfo.roadWidth)) {\n    return null;\n  }\n\n  for (let i = 0; i < roadInfo.length; i++) {\n    const road = roadInfo[i];\n\n    points[i] = { forward: [], backward: [], angle: road.angle };\n\n    /* maxDistance = pixels from the center to the edge */\n    const maxDistance =\n      ((road.numberOfForward + road.numberOfBackward - 1) *\n        coordInfo.roadWidth) /\n      2;\n\n    const allLanes = road.numberOfForward + road.numberOfBackward;\n\n    for (let j = 0; j < allLanes; j++) {\n      let firstPoint = sumVector(\n        /* sum vector pointing east to get left or right */\n        lenDeg(maxDistance - j * coordInfo.roadWidth, road.angle - 90),\n        /* and the vector, responsible for making the center area */\n        lenDeg(coordInfo.maxRoadWidth * coordInfo.roadWidth * 0.8, road.angle)\n      );\n\n      let lastPoint = sumVector(\n        firstPoint,\n        lenDeg(coordInfo.roadLength, road.angle)\n      );\n\n      if (j >= road.numberOfBackward) {\n        points[i].forward.push({ first: firstPoint, last: lastPoint });\n      } else {\n        points[i].backward.push({ first: firstPoint, last: lastPoint });\n      }\n    }\n  }\n  return points;\n}\n","import React from \"react\";\nimport \"./App.css\";\n/* import { Typography } from \"@material-ui/core\";\nimport { useSpring, animated, config } from \"react-spring\";\nimport { useGesture } from \"react-use-gesture\"; */\nimport Artboard from \"./Artboard.js\";\n\n\nexport default function App() {\n  const roadInfo = [\n    {\n      numberOfForward: 1,\n      numberOfBackward: 2,\n      angle: 10,\n    },\n   {\n      numberOfForward: 1,\n      numberOfBackward: 1,\n      angle: 110,\n    },\n    {\n      numberOfForward: 2,\n      numberOfBackward: 2,\n      angle: 180,\n    },\n    {\n      numberOfForward: 1,\n      numberOfBackward: 1,\n      angle: 300,\n    },\n  ];\n  return (\n    <>\n      <Artboard roadInfo={roadInfo}/>\n      {/* <Solution />\n      <Inventory /> */}\n    </>\n  );\n}\n/* function Solution() {\n  return (\n    <Typography variant=\"body1\">\n      Solution\n      <br />\n    </Typography>\n  );\n}\n\nfunction Inventory() {\n  return (\n    <>\n      <Item />\n      <Item />\n    </>\n  );\n}\n\nfunction Item() {\n  const [{ x, y }, setSpring] = useSpring(() => ({\n    x: 0,\n    y: 0,\n    config: config.stiff,\n  }));\n\n  const [isClicking, setIsClicking] = useState(false);\n\n  const bind = useGesture({\n    onDrag: ({ down, movement: [mx, my] }) => {\n      setSpring({ x: down ? mx : 0, y: down ? my : 0 });\n      setIsClicking(!mx && !my);\n    },\n    onDragEnd: ({ event }) => {\n      if (isClicking) {\n        console.log(\"Click\");\n      } else {\n        console.log(\"Move\", event.x, event.y);\n      }\n    },\n  });\n\n  return <animated.div className=\"drag\" {...bind()} style={{ x, y }} />;\n}\n */\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}